<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>Adding Next and Previous post link to the blog - Nate Spilman - Website and Blog</title><meta name="gridsome:hash" content="1acd9ff7544f5ebc679a6336555ee451878b9c4a"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.13"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" name="description" content="A seemingly hacky way to handle pagination"><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.c80fec4a30576dc445ab6aaefa7ada40.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="32x32" href="/assets/static/favicon.ac8d93a.c80fec4a30576dc445ab6aaefa7ada40.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="96x96" href="/assets/static/favicon.b9532cc.c80fec4a30576dc445ab6aaefa7ada40.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="76x76" href="/assets/static/favicon.f22e9f3.c80fec4a30576dc445ab6aaefa7ada40.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="152x152" href="/assets/static/favicon.62d22cb.c80fec4a30576dc445ab6aaefa7ada40.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="120x120" href="/assets/static/favicon.1539b60.c80fec4a30576dc445ab6aaefa7ada40.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="167x167" href="/assets/static/favicon.dc0cdc5.c80fec4a30576dc445ab6aaefa7ada40.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="180x180" href="/assets/static/favicon.7b22250.c80fec4a30576dc445ab6aaefa7ada40.png"><link rel="preload" href="/assets/css/0.styles.fd367411.css" as="style"><link rel="preload" href="/assets/js/app.007676c5.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--post-vue.a6d96d51.js" as="script"><link rel="prefetch" href="/assets/js/8.bf9ed3fe.js"><link rel="prefetch" href="/assets/js/page--src--pages--404-vue.4c21ad69.js"><link rel="prefetch" href="/assets/js/page--src--pages--blog-vue.3b14c5f2.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.3cef7730.js"><link rel="prefetch" href="/assets/js/page--src--pages--tags-vue.78ac3027.js"><link rel="prefetch" href="/assets/js/page--src--templates--tag-vue.7cf76674.js"><link rel="stylesheet" href="/assets/css/0.styles.fd367411.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body >
    <div id="app" data-server-rendered="true"><div id="wrapper"><div id="main"><div class="inner"><header id="header"><a href="/" class="logo active"><strong>Nate Spilman</strong> dot com
          </a><ul class="icons"><li><a href="https://twitter.com/Natetheperson" target="_blank" rel="noopener" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li><li><a href="https://www.instagram.com/natespilman/" target="_blank" rel="noopener" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li><li><a href="https://github.com/nspilman" target="_blank" class="icon brands fa-github"><span class="label">GitHub</span></a></li><li><a href="https://www.linkedin.com/in/natespilman/" target="_blank" class="icon brands fa-linkedin"><span class="label">LinkedIn</span></a></li></ul></header><article id="home" class="panel special"><div id="post-main"><article class="post"><header><h1>Adding Next and Previous post link to the blog</h1><p>A seemingly hacky way to handle pagination</p><time datetime="2015-11-01" class="published">Saturday, March 28, 2020</time></header><div id="post-body"><p>Readers of the blog will now see links to previous and next blog posts at the bottom of the page! I've accomplished this via what feels like a hack, as it's really not a scaleable solution... but it works for now!</p>
<p>At a high level - </p>
<ul>
<li>I added a new graphQL query that gets the path, title and date of ALL published blog posts. </li>
<li>I've created three Vue computed properties to grab the current post index, previous post and next post. </li>
<li>I've added links to the previous and next computed posts. </li>
</ul>
<hr>
<h3 id="the-new-graphql-query--"><a href="#the-new-graphql-query--" aria-hidden="true"><span class="icon icon-link"></span></a>The new GraphQL query -</h3>
<pre><code class="language-graphQL">&#x3C;static-query>
query {
  posts: allPost(filter: { published: { eq: true }}, sortBy: "date", order: ASC) {
    edges {
      node {
        id
        title
        path
         }
       }
     }
   }
&#x3C;/static-query>
</code></pre>
<p>The above query grabs all posts that are published, ordered by published date. </p>
<hr>
<h3 id="the-new-vue-computed-properties--"><a href="#the-new-vue-computed-properties--" aria-hidden="true"><span class="icon icon-link"></span></a>The new Vue computed properties -</h3>
<pre><code class="language-javascript">computed:{
    currentIndex(){
      return this.$static.posts.edges.map(edge => edge.node.path).indexOf(this.$page.post.path)
    },
    nextPost(){
      if(this.currentIndex &#x3C; this.$static.posts.edges.length -1){
        const nextIndex = this.currentIndex + 1;
        return this.$static.posts.edges[nextIndex].node
      }
      else{
        return -1
      }
    },
      previousPost(){
      if(this.currentIndex > 0){
        const previousPost = this.currentIndex - 1;
        return this.$static.posts.edges[previousPost].node
      }
      else{
        return -1
      }
    }
  }
</code></pre>
<p>The first computed property - <code>currentIndex</code> -  grabs the index of the current post with relation to the posts query. I convert the list of all posts to a list of the post paths via a <code>map</code> statement, and then use <code>.indexOf(path)</code> to return an index value. This will be my 4th published post, so the index will be 3. </p>
<p>The second and third computed properties - <code>nextPost</code> and <code>previousPost</code> take the <code>currentIndex</code> value, check that there won't be an index out of range error, and then returns that post value. </p>
<hr>
<h3 id="adding-the-links-on-the-page"><a href="#adding-the-links-on-the-page" aria-hidden="true"><span class="icon icon-link"></span></a>Adding the links on the page</h3>
<pre><code class="language-html">&#x3C;ul
      :style="{
            display: `flex`,
            flexWrap: `wrap`,
            justifyContent: `space-between`,
            listStyle: `none`,
            padding: '2em',
          }"
    >
      &#x3C;li v-if="previousPost">
        &#x3C;g-link :to="previousPost.path"> {{previousPost.title}} &#x3C;/g-link>
      &#x3C;/li>
      &#x3C;li v-if="nextPost">
        &#x3C;g-link :to="nextPost.path"> {{nextPost.title}} &#x3C;/g-link>
      &#x3C;/li>
    &#x3C;/ul>
</code></pre>
<p>At the bottom of the `Post.vue` template that is used to render all the posts, I've added the above code to render the previous and next posts, if they exist. <code>-1</code> coalesces to <code>false</code>, which is nice, because we can <code>v-if="previousPost"</code> instead of <code>v-if="previousPost != -1"</code>. We have the path and the title from our graphql query, which we use for linking and display. </p>
<hr>
<h3 id="wrap-up"><a href="#wrap-up" aria-hidden="true"><span class="icon icon-link"></span></a>wrap up</h3>
<p>And that's it! I refer to this as hacky, since if I find myself at a point where I have 1000 blog posts, every blogpost pageload is going to pull ALL 1000 posts into memory to find the next and previous post. Obviously not ideal, but functioning for now!!</p>
<p>Thanks for reading. </p>
</div></article><ul style="display:flex;flex-wrap:wrap;justify-content:space-between;list-style:none;padding:2em;"><li><a href="/blog/the-tech-behind-this-website/"> The tech behind this website </a></li><li><a href="/blog/my-best-of-beginner-software-development-educational-resources-list/"> My best-of beginner software development educational resources list </a></li></ul></div></article></div></div><div id="sidebar-wrapper" style="width:25em;"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b2/Hamburger_icon.svg/440px-Hamburger_icon.svg.png" class="toggle" style="left:22em;"><div id="sidebar"><div class="inner"><section id="search" class="alt"></section><nav id="menu"><header class="major"><h2>Menu</h2></header><ul><li><a href="/" class="active">Home</a></li><li><a href="/blog" class="active">Blog</a></li><li><a href="https://natespilman.tech/media/pdfs/2019_Resume.pdf" target="_blank" rel="noopener">Resume</a></li></ul></nav></div></div></div></div></div>
    <script>window.__INITIAL_STATE__={"data":{"post":{"title":"Adding Next and Previous post link to the blog","description":"A seemingly hacky way to handle pagination","path":"\u002Fblog\u002Fadding-next-and-previous-post-link\u002F","content":"\u003Cp\u003EReaders of the blog will now see links to previous and next blog posts at the bottom of the page! I've accomplished this via what feels like a hack, as it's really not a scaleable solution... but it works for now!\u003C\u002Fp\u003E\n\u003Cp\u003EAt a high level - \u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EI added a new graphQL query that gets the path, title and date of ALL published blog posts. \u003C\u002Fli\u003E\n\u003Cli\u003EI've created three Vue computed properties to grab the current post index, previous post and next post. \u003C\u002Fli\u003E\n\u003Cli\u003EI've added links to the previous and next computed posts. \u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"the-new-graphql-query--\"\u003E\u003Ca href=\"#the-new-graphql-query--\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EThe new GraphQL query -\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-graphQL\"\u003E&#x3C;static-query\u003E\nquery {\n  posts: allPost(filter: { published: { eq: true }}, sortBy: \"date\", order: ASC) {\n    edges {\n      node {\n        id\n        title\n        path\n         }\n       }\n     }\n   }\n&#x3C;\u002Fstatic-query\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThe above query grabs all posts that are published, ordered by published date. \u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"the-new-vue-computed-properties--\"\u003E\u003Ca href=\"#the-new-vue-computed-properties--\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EThe new Vue computed properties -\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Ecomputed:{\n    currentIndex(){\n      return this.$static.posts.edges.map(edge =\u003E edge.node.path).indexOf(this.$page.post.path)\n    },\n    nextPost(){\n      if(this.currentIndex &#x3C; this.$static.posts.edges.length -1){\n        const nextIndex = this.currentIndex + 1;\n        return this.$static.posts.edges[nextIndex].node\n      }\n      else{\n        return -1\n      }\n    },\n      previousPost(){\n      if(this.currentIndex \u003E 0){\n        const previousPost = this.currentIndex - 1;\n        return this.$static.posts.edges[previousPost].node\n      }\n      else{\n        return -1\n      }\n    }\n  }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThe first computed property - \u003Ccode\u003EcurrentIndex\u003C\u002Fcode\u003E -  grabs the index of the current post with relation to the posts query. I convert the list of all posts to a list of the post paths via a \u003Ccode\u003Emap\u003C\u002Fcode\u003E statement, and then use \u003Ccode\u003E.indexOf(path)\u003C\u002Fcode\u003E to return an index value. This will be my 4th published post, so the index will be 3. \u003C\u002Fp\u003E\n\u003Cp\u003EThe second and third computed properties - \u003Ccode\u003EnextPost\u003C\u002Fcode\u003E and \u003Ccode\u003EpreviousPost\u003C\u002Fcode\u003E take the \u003Ccode\u003EcurrentIndex\u003C\u002Fcode\u003E value, check that there won't be an index out of range error, and then returns that post value. \u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"adding-the-links-on-the-page\"\u003E\u003Ca href=\"#adding-the-links-on-the-page\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EAdding the links on the page\u003C\u002Fh3\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-html\"\u003E&#x3C;ul\n      :style=\"{\n            display: `flex`,\n            flexWrap: `wrap`,\n            justifyContent: `space-between`,\n            listStyle: `none`,\n            padding: '2em',\n          }\"\n    \u003E\n      &#x3C;li v-if=\"previousPost\"\u003E\n        &#x3C;g-link :to=\"previousPost.path\"\u003E {{previousPost.title}} &#x3C;\u002Fg-link\u003E\n      &#x3C;\u002Fli\u003E\n      &#x3C;li v-if=\"nextPost\"\u003E\n        &#x3C;g-link :to=\"nextPost.path\"\u003E {{nextPost.title}} &#x3C;\u002Fg-link\u003E\n      &#x3C;\u002Fli\u003E\n    &#x3C;\u002Ful\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EAt the bottom of the `Post.vue` template that is used to render all the posts, I've added the above code to render the previous and next posts, if they exist. \u003Ccode\u003E-1\u003C\u002Fcode\u003E coalesces to \u003Ccode\u003Efalse\u003C\u002Fcode\u003E, which is nice, because we can \u003Ccode\u003Ev-if=\"previousPost\"\u003C\u002Fcode\u003E instead of \u003Ccode\u003Ev-if=\"previousPost != -1\"\u003C\u002Fcode\u003E. We have the path and the title from our graphql query, which we use for linking and display. \u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Ch3 id=\"wrap-up\"\u003E\u003Ca href=\"#wrap-up\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003Ewrap up\u003C\u002Fh3\u003E\n\u003Cp\u003EAnd that's it! I refer to this as hacky, since if I find myself at a point where I have 1000 blog posts, every blogpost pageload is going to pull ALL 1000 posts into memory to find the next and previous post. Obviously not ideal, but functioning for now!!\u003C\u002Fp\u003E\n\u003Cp\u003EThanks for reading. \u003C\u002Fp\u003E\n","date":"2020-03-28T17:13:36.586Z"}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.007676c5.js" defer></script><script src="/assets/js/page--src--templates--post-vue.a6d96d51.js" defer></script>
  </body>
</html>
