{"hash":"1acd9ff7544f5ebc679a6336555ee451878b9c4a","data":{"post":{"title":"Adding Next and Previous post link to the blog","description":"A seemingly hacky way to handle pagination","path":"/blog/adding-next-and-previous-post-link/","content":"<p>Readers of the blog will now see links to previous and next blog posts at the bottom of the page! I've accomplished this via what feels like a hack, as it's really not a scaleable solution... but it works for now!</p>\n<p>At a high level - </p>\n<ul>\n<li>I added a new graphQL query that gets the path, title and date of ALL published blog posts. </li>\n<li>I've created three Vue computed properties to grab the current post index, previous post and next post. </li>\n<li>I've added links to the previous and next computed posts. </li>\n</ul>\n<hr>\n<h3 id=\"the-new-graphql-query--\"><a href=\"#the-new-graphql-query--\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>The new GraphQL query -</h3>\n<pre><code class=\"language-graphQL\">&#x3C;static-query>\nquery {\n  posts: allPost(filter: { published: { eq: true }}, sortBy: \"date\", order: ASC) {\n    edges {\n      node {\n        id\n        title\n        path\n         }\n       }\n     }\n   }\n&#x3C;/static-query>\n</code></pre>\n<p>The above query grabs all posts that are published, ordered by published date. </p>\n<hr>\n<h3 id=\"the-new-vue-computed-properties--\"><a href=\"#the-new-vue-computed-properties--\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>The new Vue computed properties -</h3>\n<pre><code class=\"language-javascript\">computed:{\n    currentIndex(){\n      return this.$static.posts.edges.map(edge => edge.node.path).indexOf(this.$page.post.path)\n    },\n    nextPost(){\n      if(this.currentIndex &#x3C; this.$static.posts.edges.length -1){\n        const nextIndex = this.currentIndex + 1;\n        return this.$static.posts.edges[nextIndex].node\n      }\n      else{\n        return -1\n      }\n    },\n      previousPost(){\n      if(this.currentIndex > 0){\n        const previousPost = this.currentIndex - 1;\n        return this.$static.posts.edges[previousPost].node\n      }\n      else{\n        return -1\n      }\n    }\n  }\n</code></pre>\n<p>The first computed property - <code>currentIndex</code> -  grabs the index of the current post with relation to the posts query. I convert the list of all posts to a list of the post paths via a <code>map</code> statement, and then use <code>.indexOf(path)</code> to return an index value. This will be my 4th published post, so the index will be 3. </p>\n<p>The second and third computed properties - <code>nextPost</code> and <code>previousPost</code> take the <code>currentIndex</code> value, check that there won't be an index out of range error, and then returns that post value. </p>\n<hr>\n<h3 id=\"adding-the-links-on-the-page\"><a href=\"#adding-the-links-on-the-page\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Adding the links on the page</h3>\n<pre><code class=\"language-html\">&#x3C;ul\n      :style=\"{\n            display: `flex`,\n            flexWrap: `wrap`,\n            justifyContent: `space-between`,\n            listStyle: `none`,\n            padding: '2em',\n          }\"\n    >\n      &#x3C;li v-if=\"previousPost\">\n        &#x3C;g-link :to=\"previousPost.path\"> {{previousPost.title}} &#x3C;/g-link>\n      &#x3C;/li>\n      &#x3C;li v-if=\"nextPost\">\n        &#x3C;g-link :to=\"nextPost.path\"> {{nextPost.title}} &#x3C;/g-link>\n      &#x3C;/li>\n    &#x3C;/ul>\n</code></pre>\n<p>At the bottom of the `Post.vue` template that is used to render all the posts, I've added the above code to render the previous and next posts, if they exist. <code>-1</code> coalesces to <code>false</code>, which is nice, because we can <code>v-if=\"previousPost\"</code> instead of <code>v-if=\"previousPost != -1\"</code>. We have the path and the title from our graphql query, which we use for linking and display. </p>\n<hr>\n<h3 id=\"wrap-up\"><a href=\"#wrap-up\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>wrap up</h3>\n<p>And that's it! I refer to this as hacky, since if I find myself at a point where I have 1000 blog posts, every blogpost pageload is going to pull ALL 1000 posts into memory to find the next and previous post. Obviously not ideal, but functioning for now!!</p>\n<p>Thanks for reading. </p>\n","date":"2020-03-28T17:13:36.586Z"}},"context":{}}