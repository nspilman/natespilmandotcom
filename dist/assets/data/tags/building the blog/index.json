{"hash":"1acd9ff7544f5ebc679a6336555ee451878b9c4a","data":{"tag":{"title":"building the blog","belongsTo":{"edges":[{"node":{"title":"Adding Next and Previous post link to the blog","path":"/blog/adding-next-and-previous-post-link/","description":"A seemingly hacky way to handle pagination","tags":[{"title":"Meta"},{"title":"Software"},{"title":"Gridsome"},{"title":"graphql"},{"title":"building the blog"}],"date":"28. March 2020","content":"<p>Readers of the blog will now see links to previous and next blog posts at the bottom of the page! I've accomplished this via what feels like a hack, as it's really not a scaleable solution... but it works for now!</p>\n<p>At a high level - </p>\n<ul>\n<li>I added a new graphQL query that gets the path, title and date of ALL published blog posts. </li>\n<li>I've created three Vue computed properties to grab the current post index, previous post and next post. </li>\n<li>I've added links to the previous and next computed posts. </li>\n</ul>\n<hr>\n<h3 id=\"the-new-graphql-query--\"><a href=\"#the-new-graphql-query--\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>The new GraphQL query -</h3>\n<pre><code class=\"language-graphQL\">&#x3C;static-query>\nquery {\n  posts: allPost(filter: { published: { eq: true }}, sortBy: \"date\", order: ASC) {\n    edges {\n      node {\n        id\n        title\n        path\n         }\n       }\n     }\n   }\n&#x3C;/static-query>\n</code></pre>\n<p>The above query grabs all posts that are published, ordered by published date. </p>\n<hr>\n<h3 id=\"the-new-vue-computed-properties--\"><a href=\"#the-new-vue-computed-properties--\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>The new Vue computed properties -</h3>\n<pre><code class=\"language-javascript\">computed:{\n    currentIndex(){\n      return this.$static.posts.edges.map(edge => edge.node.path).indexOf(this.$page.post.path)\n    },\n    nextPost(){\n      if(this.currentIndex &#x3C; this.$static.posts.edges.length -1){\n        const nextIndex = this.currentIndex + 1;\n        return this.$static.posts.edges[nextIndex].node\n      }\n      else{\n        return -1\n      }\n    },\n      previousPost(){\n      if(this.currentIndex > 0){\n        const previousPost = this.currentIndex - 1;\n        return this.$static.posts.edges[previousPost].node\n      }\n      else{\n        return -1\n      }\n    }\n  }\n</code></pre>\n<p>The first computed property - <code>currentIndex</code> -  grabs the index of the current post with relation to the posts query. I convert the list of all posts to a list of the post paths via a <code>map</code> statement, and then use <code>.indexOf(path)</code> to return an index value. This will be my 4th published post, so the index will be 3. </p>\n<p>The second and third computed properties - <code>nextPost</code> and <code>previousPost</code> take the <code>currentIndex</code> value, check that there won't be an index out of range error, and then returns that post value. </p>\n<hr>\n<h3 id=\"adding-the-links-on-the-page\"><a href=\"#adding-the-links-on-the-page\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Adding the links on the page</h3>\n<pre><code class=\"language-html\">&#x3C;ul\n      :style=\"{\n            display: `flex`,\n            flexWrap: `wrap`,\n            justifyContent: `space-between`,\n            listStyle: `none`,\n            padding: '2em',\n          }\"\n    >\n      &#x3C;li v-if=\"previousPost\">\n        &#x3C;g-link :to=\"previousPost.path\"> {{previousPost.title}} &#x3C;/g-link>\n      &#x3C;/li>\n      &#x3C;li v-if=\"nextPost\">\n        &#x3C;g-link :to=\"nextPost.path\"> {{nextPost.title}} &#x3C;/g-link>\n      &#x3C;/li>\n    &#x3C;/ul>\n</code></pre>\n<p>At the bottom of the `Post.vue` template that is used to render all the posts, I've added the above code to render the previous and next posts, if they exist. <code>-1</code> coalesces to <code>false</code>, which is nice, because we can <code>v-if=\"previousPost\"</code> instead of <code>v-if=\"previousPost != -1\"</code>. We have the path and the title from our graphql query, which we use for linking and display. </p>\n<hr>\n<h3 id=\"wrap-up\"><a href=\"#wrap-up\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>wrap up</h3>\n<p>And that's it! I refer to this as hacky, since if I find myself at a point where I have 1000 blog posts, every blogpost pageload is going to pull ALL 1000 posts into memory to find the next and previous post. Obviously not ideal, but functioning for now!!</p>\n<p>Thanks for reading. </p>\n"}}]}},"allTag":{"edges":[{"node":{"id":"beer","path":"/tags/beer/"}},{"node":{"id":"Notes","path":"/tags/Notes/"}},{"node":{"id":"vue.js","path":"/tags/vue.js/"}},{"node":{"id":"namecheap","path":"/tags/namecheap/"}},{"node":{"id":"netlifycms","path":"/tags/netlifycms/"}},{"node":{"id":"Netlify","path":"/tags/Netlify/"}},{"node":{"id":"meta","path":"/tags/meta/"}},{"node":{"id":"javascript","path":"/tags/javascript/"}},{"node":{"id":"CHOP","path":"/tags/CHOP/"}},{"node":{"id":"protest","path":"/tags/protest/"}},{"node":{"id":"BLM","path":"/tags/BLM/"}},{"node":{"id":"seattle","path":"/tags/seattle/"}},{"node":{"id":"test","path":"/tags/test/"}},{"node":{"id":"a multi-word tag","path":"/tags/a%20multi-word%20tag/"}},{"node":{"id":"singlewordtag","path":"/tags/singlewordtag/"}},{"node":{"id":"Everyone Plays the Same Song","path":"/tags/Everyone%20Plays%20the%20Same%20Song/"}},{"node":{"id":"Google Sheets","path":"/tags/Google%20Sheets/"}},{"node":{"id":"Google Forms","path":"/tags/Google%20Forms/"}},{"node":{"id":"education","path":"/tags/education/"}},{"node":{"id":"pillow","path":"/tags/pillow/"}},{"node":{"id":"data science","path":"/tags/data%20science/"}},{"node":{"id":"histogram","path":"/tags/histogram/"}},{"node":{"id":"matplotlib","path":"/tags/matplotlib/"}},{"node":{"id":"update","path":"/tags/update/"}},{"node":{"id":"misc","path":"/tags/misc/"}},{"node":{"id":"twitter","path":"/tags/twitter/"}},{"node":{"id":"guitar","path":"/tags/guitar/"}},{"node":{"id":"everyone plays the same song","path":"/tags/everyone%20plays%20the%20same%20song/"}},{"node":{"id":"organizing","path":"/tags/organizing/"}},{"node":{"id":"projects","path":"/tags/projects/"}},{"node":{"id":"creative","path":"/tags/creative/"}},{"node":{"id":"covers","path":"/tags/covers/"}},{"node":{"id":"career","path":"/tags/career/"}},{"node":{"id":"tech","path":"/tags/tech/"}},{"node":{"id":"software","path":"/tags/software/"}},{"node":{"id":"mido","path":"/tags/mido/"}},{"node":{"id":"midi","path":"/tags/midi/"}},{"node":{"id":"music","path":"/tags/music/"}},{"node":{"id":"python","path":"/tags/python/"}},{"node":{"id":"building the blog","path":"/tags/building%20the%20blog/"}},{"node":{"id":"graphql","path":"/tags/graphql/"}},{"node":{"id":"Gridsome","path":"/tags/Gridsome/"}},{"node":{"id":"Software","path":"/tags/Software/"}},{"node":{"id":"Meta","path":"/tags/Meta/"}}]}},"context":{}}